import { configRead, configAddChangeListener, configRemoveChangeListener } from './config.js';

let player = null;
let lastVideoId = null;
let qualityTimer = null;
let stateHandler = null;
let initTimer = null;
let configCleanup = null;
let isDestroyed = false;
let lastWriteTime = 0;

// Enhanced debugging
const DEBUG = true;
const log = (...args) => DEBUG && console.log('[VideoQuality]', ...args);
const warn = (...args) => console.warn('[VideoQuality]', ...args);
const info = (...args) => console.info('[VideoQuality]', ...args);

// Player States - Log all possible states for debugging
const STATE_UNSTARTED = -1;
const STATE_ENDED = 0;
const STATE_PLAYING = 1;
const STATE_PAUSED = 2;
const STATE_BUFFERING = 3;
const STATE_CUED = 5;

const STATE_NAMES = {
  '-1': 'UNSTARTED',
  '0': 'ENDED',
  '1': 'PLAYING',
  '2': 'PAUSED',
  '3': 'BUFFERING',
  '5': 'CUED'
};

function getPlayerDebugInfo() {
  if (!player) return 'Player: null';
  
  try {
    const videoData = player.getVideoData?.();
    const quality = player.getPlaybackQuality?.();
    const qualityLabel = player.getPlaybackQualityLabel?.();
    const availableQualities = player.getAvailableQualityLevels?.();
    const playerState = player.getPlayerState?.();
    const currentTime = player.getCurrentTime?.();
    const duration = player.getDuration?.();
    
    return {
      videoId: videoData?.video_id,
      title: videoData?.title,
      currentQuality: quality,
      qualityLabel: qualityLabel,
      availableQualities: availableQualities,
      playerState: playerState,
      playerStateName: STATE_NAMES[playerState] || 'UNKNOWN',
      currentTime: currentTime,
      duration: duration,
      isInline: player.isInline?.(),
      hasSetQualityRange: !!player.setPlaybackQualityRange,
      hasSetQuality: !!player.setPlaybackQuality
    };
  } catch (e) {
    return `Error getting debug info: ${e.message}`;
  }
}

function shouldForce() {
  const force = configRead('forceHighResVideo') && 
         (!player?.isInline || !player.isInline());
  log('shouldForce:', force, {
    configValue: configRead('forceHighResVideo'),
    isInline: player?.isInline?.()
  });
  return force;
}

function setLocalStorageQuality() {
  if (!shouldForce()) return;
  
  const now = Date.now();
  // Debounce/Throttle writing if done recently (e.g. 5s)
  if (now - lastWriteTime < 5000) {
    log('Skipping localStorage write (too recent)');
    return;
  }
  
  try {
    const QUALITY_KEY = 'yt-player-quality';
    const stored = window.localStorage.getItem(QUALITY_KEY);
    
    let qualityObj;
    
    if (stored) {
      // Parse existing value
      try {
        qualityObj = JSON.parse(stored);
        
        // Validate format
        if (!qualityObj || typeof qualityObj !== 'object' || 
            !qualityObj.data || !qualityObj.creation || !qualityObj.expiration) {
          throw new Error('Invalid format');
        }
        
        // Parse the inner data string
        const innerData = JSON.parse(qualityObj.data);
        log('Current localStorage quality:', innerData);
        
        // If quality is already set to target, skip write
        if (innerData.quality === 4320 && innerData.previousQuality === 4320) {
            log('Quality already at 4320, skipping');
            return; 
        }

        // Update quality values
        innerData.quality = 4320;
        innerData.previousQuality = 4320;
        
        // Reconstruct the object
        qualityObj.data = JSON.stringify(innerData);
        
      } catch (e) {
        warn('Invalid yt-player-quality format, creating new:', e);
        qualityObj = null;
      }
    }
    
    // Create new object if needed
    if (!qualityObj) {
      const now = Date.now();
      const oneYear = 365 * 24 * 60 * 60 * 1000;
      
      qualityObj = {
        data: JSON.stringify({ quality: 4320, previousQuality: 4320 }),
        creation: now,
        expiration: now + oneYear
      };
    }
    
    window.localStorage.setItem(QUALITY_KEY, JSON.stringify(qualityObj));
    lastWriteTime = now;
    info('Set localStorage quality to 4320');
    
  } catch (e) {
    warn('Failed to set localStorage quality:', e);
  }
}

function setQuality(delayMs = 0) {
  if (!player || !shouldForce() || isDestroyed) {
    log('setQuality aborted:', { 
      hasPlayer: !!player, 
      shouldForce: shouldForce(), 
      isDestroyed 
    });
    return;
  }
  
  const doSet = () => {
    try {
      if (!player.setPlaybackQualityRange) {
        warn('Player no longer valid, cleaning up');
        destroyVideoQuality();
        return;
      }
      
      const before = getPlayerDebugInfo();
      log('Setting quality. Before:', before);
      
      player.setPlaybackQualityRange('highres', 'highres');
      player.setPlaybackQuality?.('highres');
      
      // Check result after a brief delay
      setTimeout(() => {
        const after = getPlayerDebugInfo();
        log('Quality set. After:', after);
      }, 100);
      
      setLocalStorageQuality();
    } catch (e) {
      warn('Error setting quality:', e);
    }
  };
  
  if (delayMs > 0) {
    log(`Delaying quality set by ${delayMs}ms`);
    setTimeout(doSet, delayMs);
  } else {
    doSet();
  }
}

function clearTimer() {
  if (qualityTimer) {
    clearTimeout(qualityTimer);
    qualityTimer = null;
  }
}

function checkQuality(tries = 1) {
  clearTimer();
  
  if (!shouldForce() || !player || tries > 5 || isDestroyed) {
    log('checkQuality stopping:', { tries, shouldForce: shouldForce(), hasPlayer: !!player, isDestroyed });
    return;
  }
  
  try {
    const info = getPlayerDebugInfo();
    log(`Quality check attempt ${tries}:`, info);
    
    const label = player.getPlaybackQualityLabel?.() || '';
    if (!label || label === 'auto') {
      log(`Quality still auto/empty after ${tries} tries, checking again in 1s`);
      qualityTimer = setTimeout(() => checkQuality(tries + 1), 1000);
    } else {
      log(`Quality appears set to: ${label}`);
    }
  } catch (e) {
    warn('Error checking quality:', e);
    clearTimer();
  }
}

function onStateChange(state) {
  log('State change:', state, STATE_NAMES[state] || 'UNKNOWN');
  
  if (isDestroyed || !player) {
    log('State change ignored (destroyed or no player)');
    return;
  }
  
  const debugInfo = getPlayerDebugInfo();
  log('Full player state:', debugInfo);
  
  if (!shouldForce()) {
    log('Force quality disabled, ignoring state change');
    return;
  }
  
  try {
    // Handle different states
    if (state === STATE_BUFFERING) {
      log('Player is buffering, waiting for PLAYING state');
    } else if (state === STATE_PLAYING) {
      const videoData = player.getVideoData?.();
      const videoId = videoData?.video_id;
      
      log('PLAYING state detected', {
        videoId,
        lastVideoId,
        isNewVideo: videoId !== lastVideoId
      });
      
      // We check if the video ID changed OR if it's the first run (lastVideoId is null)
      if (videoId && videoId !== lastVideoId) {
        lastVideoId = videoId;
        info('New video playback detected, enforcing quality with delay');
        
        // SMOKING GUN FIX: Add a delay before setting quality on webOS 25
        // This allows the player to fully initialize before we modify it
        setQuality(1500); // 1.5 second delay
        
        // Also check quality after a longer delay
        qualityTimer = setTimeout(checkQuality, 3000);
      } else if (videoId === lastVideoId) {
        log('Same video continuing to play, not resetting quality');
      }
    } else if (state === STATE_CUED) {
      log('Video cued but not playing yet');
    } else if (state === STATE_UNSTARTED) {
      log('Video unstarted');
    }
  } catch (e) {
    warn('Error in state change handler:', e);
  }
}

export function destroyVideoQuality() {
  info('Destroying video quality manager');
  
  isDestroyed = true;
  
  if (initTimer) {
    clearTimeout(initTimer);
    initTimer = null;
  }
  
  clearTimer();
  
  if (player && stateHandler) {
    try {
      player.removeEventListener?.('onStateChange', stateHandler);
      log('Removed state change listener');
    } catch (e) {
      warn('Error removing event listener:', e);
    }
  }
  
  if (configCleanup) {
    try {
      configCleanup();
      log('Config cleanup completed');
    } catch (e) {
      warn('Error in config cleanup:', e);
    }
  }
  
  player = null;
  stateHandler = null;
  lastVideoId = null;
  configCleanup = null;
}

export function initVideoQuality() {
  if (initTimer || player) {
    info('Already initialized or initializing, skipping');
    return;
  }
  
  info('Initializing video quality manager');
  isDestroyed = false;
  
  const attach = () => {
    if (isDestroyed) {
      log('Attach aborted - destroyed');
      return true;
    }
    
    const playerContainer = document.getElementById('ytlr-player__player-container');
    const root = playerContainer || document;
    
    log('Looking for player in:', playerContainer ? 'ytlr-player__player-container' : 'document');
    
    const p = root.querySelector('.html5-video-player');
    
    const isConnected = p && (p.isConnected !== undefined ? p.isConnected : document.contains(p));
    
    log('Player search result:', {
      found: !!p,
      hasSetQualityRange: !!p?.setPlaybackQualityRange,
      isConnected
    });
    
    if (!p || !p.setPlaybackQualityRange || !isConnected) {
      return false;
    }
    
    try {
      player = p;
      stateHandler = onStateChange;
      
      log('Attaching event listener');
      player.removeEventListener?.('onStateChange', stateHandler);
      player.addEventListener?.('onStateChange', stateHandler);
      
      // Log initial state
      const initialInfo = getPlayerDebugInfo();
      log('Initial player state:', initialInfo);
           
      // Set up config listener after player is attached
      if (configAddChangeListener && !configCleanup) {
        const onChange = (evt) => {
          if (isDestroyed) return;
          
          log('Config changed:', evt.detail);
          
          if (evt.detail.newValue) {
            setQuality(500); // Small delay when manually enabling
          }
        };
        
        configCleanup = configAddChangeListener('forceHighResVideo', onChange) || 
          (() => configRemoveChangeListener?.('forceHighResVideo', onChange));
        
        log('Config listener attached');
      }
      
      info('Successfully attached to player');
      return true;
    } catch (e) {
      warn('Error attaching to player:', e);
      player = null;
      return false;
    }
  };

  if (attach()) return;

  // Wait for YouTube app to initialize to attach
  log('Player not ready, starting polling');
  let attempts = 0;
  const poll = () => {
    if (isDestroyed) {
      clearTimeout(initTimer);
      initTimer = null;
      log('Polling stopped - destroyed');
      return;
    }
    
    log(`Polling attempt ${attempts + 1}/50`);
    
    if (attach() || attempts++ >= 50) {
      clearTimeout(initTimer);
      initTimer = null;
      
      if (attempts >= 50 && !player) {
        warn('Failed to attach after 50 attempts');
      }
    } else {
      initTimer = setTimeout(poll, 200);
    }
  };
  
  poll();
}

window.addEventListener('hashchange', () => {
  const isWatchPage = window.location.hash.includes('/watch');
  log('Hash change detected', { isWatchPage, hash: window.location.hash });
  
  if (!isWatchPage && player) {
    info('Leaving watch page, cleaning up');
    destroyVideoQuality();
  }
});

window.addEventListener('beforeunload', () => {
  log('Page unloading');
  destroyVideoQuality();
});